import socket
import struct
import os

def xtea_encrypt(block, key, rounds=32):
    # Funzione di cifratura XTEA
    v0, v1 = struct.unpack('>2I', block)
    key = struct.unpack('>4I', key)
    delta = 0x9E3779B9
    sum_value = 0

    for _ in range(rounds):
        v0 = (v0 + ((v1 << 4 ^ v1 >> 5) + v1) ^ (sum_value + key[sum_value & 3])) & 0xFFFFFFFF
        sum_value = (sum_value + delta) & 0xFFFFFFFF
        v1 = (v1 + ((v0 << 4 ^ v0 >> 5) + v0) ^ (sum_value + key[sum_value >> 11 & 3])) & 0xFFFFFFFF

    return struct.pack('>2I', v0, v1)

def decrypt_xtea(payload, key):
    decrypted = b""
    for i in range(0, len(payload), 8):
        block = payload[i:i+8]
        decrypted += xtea_decrypt(block, key)
    return decrypted

def encrypt_xtea(payload, key):
    encrypted = b""
    for i in range(0, len(payload), 8):
        block = payload[i:i+8]
        encrypted += xtea_encrypt(block, key)
    return encrypted

def parse_header(header):
    header = header.lstrip(':')
    header_fields = {}
    
    for field in header.split(';'):
        if '=' in field:
            key, value = field.split('=')
            header_fields[key] = value

    try:
        header_fields['FC'] = int(header_fields.get('FC', '0'), 16)
        header_fields['PROG'] = int(header_fields.get('PROG', '0'), 16)
        header_fields['NUM'] = int(header_fields.get('NUM', '0'), 16)
        header_fields['TOT'] = int(header_fields.get('TOT', '0'), 16)
        header_fields['LEN'] = int(header_fields.get('LEN', '0'), 16)
    except ValueError:
        raise ValueError("Errore nella conversione dell'header da esadecimale a intero.")

    return header_fields

def create_response(fc, prog, key):
    if fc == 1:
        return [create_packet(1, 1, prog, fc, "UNVUD_0".encode('ascii'), key)]
    
    elif fc in (2, 3):
        # Simulazione della cattura di una "camera"
        if fc == 2:
            image_path = 'camera0.jpg'
        else:
            image_path = 'camera1.jpg'

        if not os.path.exists(image_path):
            raise FileNotFoundError(f"Immagine {image_path} non trovata.")

        with open(image_path, 'rb') as img_file:
            image_data = img_file.read()

        return create_image_packets(image_data, prog, fc, key)

def create_packet(num, tot, prog, fc, payload, key):
    len_payload = len(payload)
    
    if len_payload % 8 != 0:
        padding_length = 8 - (len_payload % 8)
        payload += b'\x00' * padding_length

    encrypted_payload = encrypt_xtea(payload, key)

    header = f":FC={fc:04X};PROG={prog:04X};NUM={num:04X};TOT={tot:04X};LEN={len_payload:04X};PAYLOAD="
    return header.encode('ascii') + encrypted_payload + chr(4).encode('ascii')

def create_image_packets(image_data, prog, fc, key):
    packets = []
    total_packets = (len(image_data) + 1023) // 1024

    for i in range(total_packets):
        start_index = i * 1024
        end_index = start_index + 1024
        packet_data = image_data[start_index:end_index]

        packet = create_packet(
            num=i + 1,
            tot=total_packets,
            prog=prog,
            fc=fc,
            payload=packet_data,
            key=key
        )
        packets.append(packet)

    return packets

def start_server():
    xtea_key = b'1234567890abcdef'

    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind(('0.0.0.0', 8000))
    server_socket.listen(1)
    print("Server in ascolto sulla porta 8000...")

    while True:
        conn, addr = server_socket.accept()
        print(f"Connessione accettata da {addr}")

        try:
            while True:
                buffer = {}
                total_packets = 0

                # Ricezione dei dati e parsing
                while True:
                    data = conn.recv(2048)
                    if not data:
                        print("Connessione chiusa dal client.")
                        return

                    try:
                        header_part, payload_part = data.decode('ascii').split('PAYLOAD=', 1)
                        header_fields = parse_header(header_part)
                    except (ValueError, UnicodeDecodeError) as e:
                        print(f"Errore nel parsing dei dati ricevuti: {e}")
                        continue

                    if payload_part[-1] == chr(4):
                        payload_part = payload_part[:-1]
                    else:
                        print("Errore: pacchetto senza terminatore chr(4)")
                        continue

                    payload_bytes = bytes.fromhex(payload_part)
                    decrypted_payload = decrypt_xtea(payload_bytes, xtea_key)
                    
                    num_valid_bytes = header_fields['LEN']
                    decrypted_payload = decrypted_payload[:num_valid_bytes]

                    num = header_fields['NUM']
                    buffer[num] = decrypted_payload.decode('ascii')

                    if total_packets == 0:
                        total_packets = header_fields['TOT']

                    if len(buffer) == total_packets:
                        break

                # Organizzazione del buffer e creazione della risposta
                sorted_buffer = [buffer[i] for i in sorted(buffer.keys())]
                full_payload = ''.join(sorted_buffer)

                print("Dati ricevuti e organizzati correttamente:")
                print(full_payload)

                fc = header_fields['FC']
                prog = header_fields['PROG']

                try:
                    response_packets = create_response(fc, prog, xtea_key)
                    for packet in response_packets:
                        conn.sendall(packet)
                except FileNotFoundError as e:
                    print(f"Errore: {e}")

        except Exception as e:
            print(f"Errore durante la gestione della connessione: {e}")
        finally:
            conn.close()
            print("Connessione chiusa.")

if __name__ == "__main__":
    start_server()

